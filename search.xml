<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML5语义化标签笔记]]></title>
    <url>%2F2019%2F01%2F18%2FHTML5%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HTML5语义化标签笔记 为什么会有h5 语义化标签在HTML5出现之前，我们一般采用DIV+CSS布局页面。但是这样的布局方式不仅使我们的文档结构不够清晰，而且不利于搜索引擎爬虫对我们页面的爬取。为了解决上述缺点，HTML5新增了很多新的语义化标签。 语义标签的概念维基百科 语义化是前端开发里面的一个专用术语，其优点在于标签语义化有助于构架良好的html结构，有利于搜索引擎的建立索引、抓取；另外，亦有利于页面在不同的设备上显示尽可能相同；此外，亦有利于构建清晰的机构，有利于团队的开发、维护。 通俗来说：语义化的意思是从名称一眼就能看出其内容和作用是什么，语义化标签就是通过使用浅显易懂的元素名和属性名来实现语义化的 语义标签有什么用？ 可以提高页面的可访问性，即在css丢失的情况下，页面结构仍然可以比较清晰的展现； 提高用户体验，用户不够清楚地方可以得到良好的解释； 有利于页面seo，让搜索引擎更容易明白页面结构和内容的主次顺序； 有利于页面维护者理解代码结构，降低维护成本； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页 常用语义标签有哪些？h1到h6标签 表示不同等级的标题 可以用来表现文本内容的层级结构 &lt;article&gt; 元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构 &lt;article&gt; 可以嵌套使用，但是他们必须是部分与整体的关系 &lt;article&gt; 元素的作者信息可通过 &lt;address&gt; 元素提供，但是不适用于嵌套的 &lt;article&gt; 元素 &lt;article&gt; 元素的发布日期和时间可通过 &lt;time&gt; 元素的pubdate属性表示 定义侧栏标签 如果使用多个 &lt;aside&gt;，标签应该在主要内容的后面，这样有利于SEO的搜索与提升可访问性 如果是与文章的主要内容有关系的图像需要用 &lt;figure&gt; 标签代替 &lt;section&gt; 元素表示文档中的一个区域（或节），比如，内容中的一个专题组，一般来说会有包含一个标题（heading） 如果元素内容可以分为几个部分的话，应该使用 &lt;article&gt; 而不是 &lt;section&gt; 不要把 &lt;section&gt; 元素作为一个普通的容器来使用。 一般来说，一个 &lt;section&gt; 应该出现在文档大纲中 &lt;header&gt; 元素用来表示一些前言性质或导航类的内容。它可以包含一些标题性质元素，也可以放置一些比如logo，搜索框，或其它的 &lt;header&gt; 元素等 &lt;header&gt; 元素并不是一个可以形成段落内容的元素，所以，不需要在内容目录里体现出来 &lt;footer&gt; 元素表示最近一个章节内容或者根节点（sectioning root）元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息 &lt;footer&gt; 元素内的作者信息应包含在 &lt;address&gt; 元素中 &lt;footer&gt; 元素不是章节内容，因此在outline中不能包含新的章节 &lt;nav&gt; 描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表 并不是所有的链接都必须使用 &lt;nav&gt; 元素,它只用来将一些热门的链接放入导航栏 一个网页也可能含有多个 &lt;nav&gt; 元素,例如一个是网站内的导航列表,另一个是本页面内的导航列表 对于屏幕阅读障碍的人,可以使用这个元素来确定是否忽略初始内容 &lt;dl&gt;,&lt;dt&gt;,&lt;dd&gt; (自定义列表) dl: 英文意思为definition list，作用是定义列表 dt: 英文意思为defines terms，作用是定义列表中的项目 dd: 英文意思为defines description，作用是定义列表中项目的注释 &lt;b&gt;/&lt;strong&gt; 元素默认均展示为加粗 &lt;b&gt; 表示“文体突出”文字，通俗讲就是突出不安分的文字。像概要中的关键字，产品名。或者代表强调的排版方式 &lt;strong&gt; 表示重程度的强调 &lt;i&gt;/&lt;em&gt; 元素默认均展示为斜体 &lt;i&gt; 表现为在文章中突出不同意见或语气或的一段文本,例如外语，科技术语、或者是排版用的斜体文字 &lt;em&gt; 表示强调 &lt;mark&gt;用来突出显示文本，他的效果就像是用荧光笔给重点的语句做标一样 &lt;address&gt; 元素可以让作者为它最近的 &lt;article&gt; 或者 &lt;body&gt; 祖先元素提供联系信息。在后一种情况下，它应用于整个文档 当表示一个和联系信息无关的任意的地址时，应使用 &lt;p&gt; 元素 这个元素不能包含除了联系信息之外的任何信息，比如出版日期 通常，&lt;address&gt; 元素可以放在当前section的 &lt;footer&gt; 元素中，如果存在的话 &lt;figure&gt; 这个元素是用来引入图表、图形、照片等，对应的场景就是像是杂志中的图片一样 &lt;figure&gt; 元素可以包含多个内容块，但是只能有一个 &lt;figcaption&gt;（可以理解成给图表加标题）标签 可以用 &lt;h1&gt; ~ &lt;h6&gt; 来给 &lt;figure&gt; 增加标题； &lt;figcaption&gt; 不能单独出现，需要有配套的内容一起出现 &lt;time&gt; 可以通过这个标签标记一个具体的时间或日期，应用场景通常就是一篇文章的发表时间 datetime中的时间最好与 &lt;time&gt; 标签中的文本元素日期一样，写法可以不一样 如果这个时间是代表整个文章或是页面的时间需要添加pubdate属性 不要在 &lt;time&gt; 标签中使用不确切的时间如：“今天中午”、“上周末” 如果 使用pubdate属性需要注意的是要在同一个父标签下面不要出现张冠李戴的问题 &lt;time&gt; 标签不能在嵌套另一个 &lt;time&gt; 标签 datatime中的时间格式需要是标准的机器可能的时间 如:YYYY-MM-DDThh:mm:ss 注意 尽可能少的使用无语义的标签div和span 在语义不明显时，既可以使用div或者p时，尽量用p，因为p在默认情况下有上下间距，对兼容特殊终端有利 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td 表单域要用fieldset标签包起来，并用legend标签说明表单的用途 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>h5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18年总结]]></title>
    <url>%2F2018%2F12%2F31%2F18%E5%B9%B4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[18年总结 2018 明天就是新的一年，18年发生了很多的事情与改变，就像今天的这份个人总结（原本是不会写总结的） 之前每到年底时候是有想过一整年发生的事情，并且计划着新一年要干成的大事，但那些都只是在脑海中想着一幅幅场景，计划着要干的一件件事情， 怀着得过且过的心态这么过这每一年 如果说16，17年是迷茫的，那么18年就是焦虑，开始慢慢懂得了一些事情，知道了自己的无知 值得记录的事情 戒烟，是的，2018年随着国庆的结束，伴随我5年半的烟瘾就已经结束，说起这个戒烟的经历，确实蛮好笑的（现在想想佩服自己），在今天8月9月的时候，抽烟确实有点太狠，我说一个数吧，白天一盒，晚上一盒，要是有打游戏，另加一盒，那段时间咳嗽的厉害，之后偶然间，发现电子烟东西，老实说，就是抱着试一试的态度买了，抽了两个星期，国庆最后一天假期，大家知道，电子烟需要充电，但因为已经上床懒得下去，第二天上班就没带，一天下来竟然发现我好像也没有之前几个小时不抽烟的那种难受感，所以就想着慢慢强迫自己结束掉这个坏习惯 感觉失败的事情 英语单词从开始到放弃 （4级词汇第一个词，abandon[放弃]）哈哈哈 跑步没有坚持（有着各种各样的原因没有坚持下来） 学习深度不够（知识点觉得会用就行） 自已一年前立的flag 去年没有 得到的教训 跳出程序员思维，重视沟通，因为自己原因，导致自己在工作频频出错，看着很努力，其实白做无用功（学习：如何进行有效高效的沟通） 换角度思维，看事情太过单一，太过局限 读了几本书 《追风筝的人》 《无妄之灾》 《被偷走的人生》 对自己重大影响的人和事 今年能够有这些想法和改变，都是因为那个人，他就是”stormzhang”，人称帅帐（张鸽），至于介绍，我就不多说了，可以上网查资料，或者关微信公众号（stormzhang） 19年计划 读书计划，2019年12本书，完成一本奖励自己一顿大餐，全部完成，奖励自己一台ipad 学习英语，短期目标，一天5个单词，年终目标能够完成英文技术文档的简单阅读，奖励自己（bose无线耳机） 博客更新，每两周时间更新学习完成任务进度 脱单 小结 以上则是18年回顾以及19年计划，19年会是一个新的开始。 请继续坚持：正确的努力，不断前行！ 2019！就是干！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次svn修改端口出现的问题]]></title>
    <url>%2F2018%2F10%2F30%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1svn%E4%BF%AE%E6%94%B9%E7%AB%AF%E5%8F%A3%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[记录一次svn修改端口出现的问题 使用svn进行代码管理，在windows服务器上面svn服务占用的是443端口，在网站升级https之后，443端口解放出来交给https了，这个时候就需更换端口，默认的端口有443和8443，我们可一切换到8443，结果在本地check代码的时候，端口也输入了，但就是check不了，提示原因也是含糊不清 问题 1.服务器端口为打开 2.服务根本没有运行 这里我们排除第二点，在修改端口之后只需重启svn服务就可以了 主要看一下服务器端口是什么原因：需要你打开服务器的端口号，在服务器上找到控制面板-&gt;防火墙-&gt;高级设置-&gt;把入站8443添加进去。 紧接着还没完，去服务器代理商，云服务器-&gt;安全组配置-&gt;配置规则-&gt;添加安全组规则添加进去8443入口]]></content>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习笔记]]></title>
    <url>%2F2018%2F10%2F21%2Fgit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[git学习笔记 从svn转到git版本控制之后，就爱上了它，再配合上github，简直不要太爽,以下是结合多方查询之后，总结出来适用于自己的git笔记！ 配置配置账号信息12345678git config -e [--global] #编辑Git配置文件git config --global user.name itxccgit config --global user.email itxcc420@gmail.comgit config --list #查看配置的信息git help config #获取帮助信息 配置密钥123ssh-keygen -t rsa -C itxccc420@gmail.com #生成密钥ssh -T git@github.com #测试是否成功 配置别名1234git config --global alias.st status #git stgit config --global alias.co checkout #git cogit config --global alias.br branch #git brgit config --global alias.ci commit #git ci 基础命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647git init #初始化git status #文件状态git add [file1] [file2] ... #.或*代表全部添加git commit -m &quot;msessage&quot; 备注：- type（文件）：‘备注’- - feat:新功能- - fix:修复bug- - style：格式- - refactor：代码重构- - chore：项目构建git push origin 分支名称 #推送到某个分支git log #查看所有提交记录git reflog #不小心删除了东西，先查到commit id，恢复git branch #显示所有本地分支git branch test #新建test分支git push git test #推送test分支到远程git checout test #切换到test分支git merge test #将test分支合并到当前分支git branch -d test #删除test分支git push origin -d test #删除远程test分支git rebase master#将master分之上超前的提交，变基到当前分支git rebase --onto master 169a6 #限制回滚范围，rebase当前分支从169a6以后的提交git rebase --interactive #交互模式 git rebase --continue# 处理完冲突继续合并 git rebase --skip# 跳过 git rebase --abort# 取消合并git tag #列出现有标签 git tag v0.1 [branch|commit] # [从指定位置]新建标签git tag -a v0.1 -m &apos;my version 1.4&apos;#新建带注释标签git checkout tagname#切换到标签git push origin v1.5#推送分支到源上git push origin --tags#一次性推送所有分支git tag -d v0.1#删除标签git push origin :refs/tags/v0.1#删除远程标签 开发流程 一般而言，会有两个公共分支&nbsp;&nbsp;&nbsp;&nbsp;master （项目主分支）&nbsp;&nbsp;&nbsp;&nbsp;dev （测试分支） 开发一般是需要在自己的分支进行开发，然后推送到远端，本地则需要git merge 本地分支来进行更新dev分支，如果是多人开发，则需要git pull来更新dev分支 在开发需要下拉代码时，远程仓库和本地刚好又有改动，最好先将自己在本地的代码进行 git stash （暂存区），再去进行下拉，在运行git stash pop 把自己的代码释放出来 添加tag &nbsp;&nbsp;&nbsp;&nbsp;git tag -a v0.0.0 -m ‘v0.0.0’ &nbsp;&nbsp;&nbsp;&nbsp;git push – tag]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome浏览器下video隐藏下载按钮]]></title>
    <url>%2F2018%2F10%2F11%2Fchrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8Bvideo%E9%9A%90%E8%97%8F%E4%B8%8B%E8%BD%BD%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[chrome浏览器下video隐藏下载按钮 用原生video标签显示一个视频，不希望有下载按钮，找到一个可以看上去没有下载功能的方法，做一下笔记。 使用 video 元素的 ControlList API1&lt;video controls controlsList=&quot;nodownload&quot;&gt;&lt;/video&gt; 通过 ControList API，不仅可以通过设置 nodownload 来隐藏下载按钮，还可以设置 nofullscreen 隐藏全屏按钮, 以及noremoteplayback 等属性，具体的示例可以参考 github pages。该方案的优点是原生支持，不会产生bug，而且设置起来也是简单方便，不过由于 ControlList API 是从 Chrome 58+ 才开始引入的，所以对于低于 58 版本的 Chrome 只能通过方法2来隐藏了。 通过 CSS 隐藏通过 Settings|Preferences -&gt; Elements -&gt; Show user agent shadow DOM 打开 shadow DOM 开关后，可以通过 devtools 查看 video 元素的组成部分。由此发现下载按钮的是通过 呈现的，所以可以通过下述CSS将其隐藏： 123video::-internal-media-controls-download-button &#123; display: none;&#125; 但是很可惜，该方法并不起作用，猜想可能是Chrome的一个BUG，所以只能另辟蹊径，简单来说就是将下载按钮挤出可见范围，这样就可以变相的认为按钮被隐藏了，代码如下： 123456video::-webkit-media-controls &#123; overflow: hidden !important;&#125;video::-webkit-media-controls-enclosure &#123; width: calc(100% + 32px); margin-left: auto;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图库网站]]></title>
    <url>%2F2018%2F09%2F23%2F%E5%9B%BE%E5%BA%93%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[图库网站 矢量素材Streamline Emojihttp://emoji.streamlineicons.com Streamline Emoji 是一个拥有 780+免费矢量表情符号的网站，表情形象非常生动、可爱，情感表述值得学习。 Undrawhttps://undraw.co unDraw 是一个很棒的扁平化设计图库，以收录插图为主，这些图案设计很有质感，原作者 Katerina Limpitsouni 仍持续不断更新中，任何人都能从这里找到美丽的插图，免费下载 SVG 或 PNG 格式，无需标示出处，也能用于商业用途。 Free Vectorhttps://www.freevector.com 网站提供超过 16000 个免费矢量素材，并且每周都有更新，同时网站底部提供非常详细的标签类别分类，能够让你更加方便查找想要的素材。 Vecteezy网址： https://www.vecteezy.com Vecteezy 是一个免费矢量图网站，收集了很多不错的图片素材，更棒的是这个网站天天更新，你可以无时无刻回来挖宝。Vecteezy 提供的文档多为 EPS、AI 与 CDR 格式，也是目前最多使用的矢量图类型。 Vector 4 Free网址： http://vector4free.com Vector4Free 是一个专门提供优质免费矢量素材的网站，文档格式有 AI、EPS、PDF、SVG、CDR 等，网站内容更新速度快、分类全，方便快速查找想要的素材，另外网站上所有的矢量素材都可以免费提供给个人使用，商业时最好检查授权说明。 图片素材Negative Space网址： https://negativespace.co/ NegativeSpace 是一个众所周知的分享摄影作品的图片网站，有大量高分辨率图片供个人或商业使用，照片除按热门标签分类外，还可按颜色分类查找。 StockSnap网址： https://stocksnap.io 一个图片丰富的资料库，每天都有摄影师上传新的相片到网站，素材更新速度快、图片分辨率高，并且没有版权限制。此外，网站还提供新增日期、趋势、查看次数、下载次数等方式来排序网站内的图片，方便用户浏览下载。 Pexels网址： https://www.pexels.com 免费高品质图片下载网站，提供海量共享图片素材，每周都会定量更新，所有的图片都会显示详细的信息，例如拍摄的相机型号、光圈、焦距、ISO、图片大分辨率等，高清大图质量很不错。 Burst网址： https://burst.shopify.com 为个人及商业用途提供免费图片的网站，浏览照片集或发现“本周最佳免费照片”，可以满足不同的主题和目的。 Pixabay网址： https://pixabay.com Pixabay 是一个有超过三十万张免费相片、矢量图与艺术插图素材的网站，图片均可用于商业用途。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[九种浏览器的缓存]]></title>
    <url>%2F2018%2F09%2F19%2F%E4%B9%9D%E7%A7%8D%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[九种浏览器的缓存 文章转载自 http://jixianqianduan.com/frontend-javascript/2015/12/28/nine-browser-cache-methods.html 浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据，整体上加速网页展示给用户。浏览器端缓存的机制种类较多，总体归纳为九种，这里详细分析下这九种缓存机制的原理和使用场景。打开浏览器的调试模式-&gt;resources左侧就有浏览器的8种缓存机制。 http缓存http缓存是基于HTTP协议的浏览器文件级缓存机制。即针对文件的重复请求情况下，浏览器可以根据协议头判断从服务器端请求文件还是从本地读取文件，chrome控制台下的Frames即展示的是浏览器的http文件级缓存。以下是浏览器缓存的整个机制流程。主要是针对重复的http请求，在有缓存的情况下判断过程主要分3步： 判断expires，如果未过期，直接读取http缓存文件，不发http请求，否则进入下一步 判断是否含有etag，有则带上if-none-match发送请求，未修改返回304，修改返回200，否则进入下一步 判断是否含有last-modified，有则带上if-modified-since发送请求，无效返回200，有效返回304，否则直接向服务器请求 如果通过etag和last-modified判断，即使返回304有至少有一次http请求，只不过返回的是304的返回内容，而不是文件内容。所以合理设计实现expires参数可以减少较多的浏览器请求。 websqlwebsql这种方式只有较新的chrome浏览器支持，并以一个独立规范形式出现，主要有以下特点 Web Sql 数据库API 实际上不是HTML5规范的组成部分； 在HTML5之前就已经存在了，是单独的规范； 它是将数据以数据库的形式存储在客户端，根据需求去读取； 跟Storage的区别是： Storage和Cookie都是以键值对的形式存在的； Web Sql 更方便于检索，允许sql语句查询； 让浏览器实现小型数据库存储功能； 这个数据库是集成在浏览器里面的，目前主流浏览器基本都已支持； websql API主要包含三个核心方法： openDatabase : 这个方法使用现有数据库或创建新数据库创建数据库对象。 transaction : 这个方法允许我们根据情况控制事务提交或回滚。 executeSql : 这个方法用于执行真实的SQL查询。 openDatabase方法可以打开已经存在的数据库，不存在则创建 1var db = openDatabase(&apos;mydatabase&apos;, &apos;2.0&apos;, &apos;my db&apos;, 2 * 1024); openDatabasek中五个参数分别为：数据库名、版本号、描述、数据库大小、创建回调。创建回调没有也可以创建数据库。 database.transaction() 函数用来查询，executeSql()用于执行sql语句 例如在mydatabase数据库中创建表t1： 1234var db = openDatabase(&apos; mydatabase &apos;, &apos;1.0&apos;, &apos;Test DB&apos;, 2 * 1024 * 1024); db.transaction(function (tx) &#123; tx.executeSql(&apos;CREATE TABLE IF NOT EXISTS t1 (id unique, log)&apos;); &#125;); 插入操作 1234567var db = openDatabase(&apos;mydatabase&apos;, &apos;2.0&apos;, &apos;my db&apos;, 2 * 1024); db.transaction(function (tx) &#123; tx.executeSql(&apos;CREATE TABLE IF NOT EXISTS t1 (id unique, log)&apos;); tx.executeSql(&apos;INSERT INTO t1 (id, log) VALUES (1, &quot;foobar&quot;)&apos;); tx.executeSql(&apos;INSERT INTO t1 (id, log) VALUES (2, &quot;logmsg&quot;)&apos;); &#125;); 在插入新记录时，我们还可以传递动态值，如： 12345var db = openDatabase(&apos; mydatabase &apos;, &apos;2.0&apos;, &apos;my db&apos;, 2 * 1024); db.transaction(function (tx) &#123; tx.executeSql(&apos;CREATE TABLE IF NOT EXISTS t1 (id unique, log)&apos;); tx.executeSql(&apos;INSERT INTO t1 (id,log) VALUES (?, ?&apos;), [e_id, e_log]; //e_id和e_log是外部变量 &#125;); 读操作，如果要读取已经存在的记录，我们使用一个回调捕获结果： 12345678910111213141516var db = openDatabase(mydatabase, &apos;2.0&apos;, &apos;my db&apos;, 2*1024); db.transaction(function (tx) &#123; tx.executeSql(&apos;CREATE TABLE IF NOT EXISTS t1 (id unique, log)&apos;); tx.executeSql(&apos;INSERT INTO t1 (id, log) VALUES (1, &quot;foobar&quot;)&apos;); tx.executeSql(&apos;INSERT INTO t1 (id, log) VALUES (2, &quot;logmsg&quot;)&apos;); &#125;); db.transaction(function (tx) &#123; tx.executeSql(&apos;SELECT * FROM t1, [], function (tx, results) &#123; var len = results.rows.length, i; msg = &quot;&lt;p&gt;Found rows: &quot; + len + &quot;&lt;/p&gt;&quot;; document.querySelector(&apos;#status&apos;).innerHTML += msg; for (i = 0; i &lt; len; i++)&#123; alert(results.rows.item(i).log ); &#125; &#125;, null); &#125;); indexDBIndexedDB 是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的 API。虽然 DOM 存储 对于存储少量数据是非常有用的，但是它对大量结构化数据的存储就显得力不从心了。IndexedDB 则提供了这样的一个解决方案。 IndexedDB 分别为同步和异步访问提供了单独的 API 。同步 API 本来是要用于仅供 Web Workers 内部使用，但是还没有被任何浏览器所实现。异步 API 在 Web Workers 内部和外部都可以使用，另外浏览器可能对indexDB有50M大小的限制，一般用户保存大量用户数据并要求数据之间有搜索需要的场景。 异步API 异步 API 方法调用完后会立即返回，而不会阻塞调用线程。要异步访问数据库，要调用 window 对象 indexedDB 属性的 open() 方法。该方法返回一个 IDBRequest 对象 (IDBOpenDBRequest)；异步操作通过在 IDBRequest 对象上触发事件来和调用程序进行通信。 同步API 规范里面还定义了 API 的同步版本。同步 API 还没有在任何浏览器中得以实现。它原本是要和 webWork 一起使用的。 http://mxr.mozilla.org/mozilla-central/source/modules/libpref/src/init/all.js http://caniuse.com/#feat=indexeddb cookieCookie（或者Cookies），指一般网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。cookie一般通过http请求中在头部一起发送到服务器端。一条cookie记录主要由键、值、域、过期时间、大小组成，一般用户保存用户的认证信息。cookie最大长度和域名个数由不同浏览器决定，具体如下： 浏览器 支持域名个数 最大长度 IE7以上 50个 4095B Firefox 50个 4097B Opera 30个 4096B Safari/WebKit 无限制 4097B 不同域名之间的cookie信息是独立的，如果需要设置共享可以在服务器端设置cookie的path和domain来实现共享。浏览器端也可以通过document.cookie来获取cookie，并通过js浏览器端也可以方便地读取/设置cookie的值。 https://github.com/component/cookie/blob/master/index.js localstoragelocalStorage是html5的一种新的本地缓存方案，目前用的比较多，一般用来存储ajax返回的数据，加快下次页面打开时的渲染速度。 浏览器 1 最大长度 2 IE7以上 5M Firefox 8以上 5.24M Opera 2M Safari/WebKit 2.6M 12345//localStorage核心API:localStorage.setItem(key, value) //设置记录localStorage.getItem(key) //获取记录localStorage.removeItem(key) //删除该域名下单条记录localStorage.clear() //删除该域名下所有记录 值得注意的是，localstorage大小有限制，不适合存放过多的数据，如果数据存放超过最大限制会报错，并移除最先保存的数据。 https://github.com/machao/localStorage sessionstorage sessionStorage和localstorage类似，但是浏览器关闭则会全部删除，api和localstorage相同，实际项目中使用较少。 application cacheapplication cahce是将大部分图片资源、js、css等静态资源放在manifest文件配置中。当页面打开时通过manifest文件来读取本地文件或是请求服务器文件。 离线访问对基于网络的应用而言越来越重要。虽然所有浏览器都有缓存机制，但它们并不可靠，也不一定总能起到预期的作用。HTML5 使用ApplicationCache 接口可以解决由离线带来的部分难题。前提是你需要访问的web页面至少被在线访问过一次。 使用缓存接口可为您的应用带来以下三个优势： 离线浏览 – 用户可在离线时浏览您的完整网站 速度 – 缓存资源为本地资源，因此加载速度较快。 服务器负载更少 – 浏览器只会从发生了更改的服务器下载资源。 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。并在下一次生效。离线的情况下，浏览器就直接使用离线存储的资源。 一个简单的离线页面主要包含以下几个部分： index.html 1234567891011&lt;html manifest="clock.manifest"&gt; &lt;head&gt; &lt;title&gt;AppCache Test&lt;/title&gt; &lt;link rel="stylesheet" href="clock.css"&gt; &lt;script src="clock.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;output id="clock"&gt;&lt;/output&gt;&lt;/p&gt; &lt;div id="log"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; clock.manifest 12345CACHE MANIFEST#VERSION 1.0CACHE:clock.cssclock.js clock.js和clock.css为独立的另外文件。 另外需要注意的是更新缓存。在程序中，你可以通过window.applicationCache 对象来访问浏览器的app cache。你可以查看 status 属性来获取cache的当前状态： 123456789101112131415161718192021222324var appCache = window.applicationCache;switch (appCache.status) &#123; case appCache.UNCACHED: // UNCACHED == 0 return 'UNCACHED'; break; case appCache.IDLE: // IDLE == 1 return 'IDLE'; break; case appCache.CHECKING: // CHECKING == 2 return 'CHECKING'; break; case appCache.DOWNLOADING: // DOWNLOADING == 3 return 'DOWNLOADING'; break; case appCache.UPDATEREADY: // UPDATEREADY == 4 return 'UPDATEREADY'; break; case appCache.OBSOLETE: // OBSOLETE == 5 return 'OBSOLETE'; break; default: return 'UKNOWN CACHE STATUS'; break;&#125;; 为了通过编程更新cache，首先调用 applicationCache.update()。这将会试图更新用户的 cache（要求manifest文件已经改变）。最后，当 applicationCache.status 处于 UPDATEREADY 状态时， 调用applicationCache.swapCache()，旧的cache就会被置换成新的。 123456var appCache = window.applicationCache;appCache.update(); // Attempt to update the user’s cache.…if (appCache.status == window.applicationCache.UPDATEREADY) &#123; appCache.swapCache(); // The fetch was successful, swap in the new cache.&#125; 这里是通过更新menifest文件来控制其它文件更新的。 cacheStorageCacheStorage是在ServiceWorker的规范中定义的。CacheStorage 可以保存每个serverWorker申明的cache对象，cacheStorage有open、match、has、delete、keys五个核心方法，可以对cache对象的不同匹配进行不同的响应。 cacheStorage.has() 如果包含cache对象，则返回一个promise对象。 cacheStorage.open() 打开一个cache对象，则返回一个promise对象。 cacheStorage.delete() 删除cache对象，成功则返回一个promise对象，否则返回false。 cacheStorage.keys() 含有keys中字符串的任意一个，则返回一个promise对象。 cacheStorage.delete() 匹配key中含有该字符串的cache对象，返回一个promise对象。 1234567caches.has(&apos;v1&apos;).then(function() &#123; caches.open(&apos;v1&apos;).then(function(cache) &#123; return cache.addAll(myAssets); &#125;);&#125;).catch(function() &#123; someCacheSetupfunction();&#125;);; 123456789101112var response;var cachedResponse = caches.match(event.request).catch(function() &#123; return fetch(event.request);&#125;).then(function(r) &#123; response = r; caches.open(&apos;v1&apos;).then(function(cache) &#123; cache.put(event.request, response); &#125;); return response.clone();&#125;).catch(function() &#123; return caches.match(&apos;/sw-test/gallery/myLittleVader.jpg&apos;);&#125;); 12345678910111213then.addEventListener(&apos;activate&apos;, function(event) &#123; var cacheWhitelist = [&apos;v2&apos;]; event.waitUntil( caches.keys().then(function(keyList) &#123; return Promise.all(keyList.map(function(key) &#123; if (cacheWhitelist.indexOf(key) === -1) &#123; return caches.delete(keyList[i]); &#125; &#125;); &#125;) );&#125;); https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage flash缓存这种方式基本不用，这一方法主要基于flash有读写浏览器端本地目录的功能，同时也可以向js提供调用的api，则页面可以通过js调用flash去读写特定的磁盘目录，达到本地数据缓存的目的。 注释 Web Storage / Web SQL Database / Indexed Database 的数据都存储在浏览器对应的用户配置文件目录(user profile directory)下，以 Windows 7 为例，Chrome 的数据存储在”C:\Users\your-account-name\AppData\Local\Google\Chrome\User Data\Default\”下，而 Firefox 的数据存储在”C:\Users\your-account-name\AppData\Local\Mozilla\Firefox\Profiles\”目录下。 cookie文件存储于documents andsettings\userName\cookie\文件夹下。通常的命名格式为：userName@domain.txt。 较多的缓存机制目前主流浏览器并不兼容，不过可以使用polyfill的方法来处理 浏览器涉及的缓存方式主要包含这些，具体结合自己的业务场景进行选择使用]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机端页面在项目中遇到的一些问题及解决办法]]></title>
    <url>%2F2018%2F09%2F18%2F%E6%89%8B%E6%9C%BA%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[手机端页面在项目中遇到的一些问题及解决办法 解决页面使用overflow: scroll在iOS上滑动卡顿的问题?首先你可能会给页面的html和body增加了height: 100%, 然后就可能造成IOS上页面滑动的卡顿问题。解决方案是： (1) 看是否能把body和html的height: 100%去除掉。 (2) 在滚动的容器中增加：-webkit-overflow-scrolling: touch或者给body增加：body {overflow-x: hidden}。 ios页面橡皮弹回效果遮挡页面选项卡？(1) 有时body和html的height: 100%去除掉问题可能就没有了。 (2) 到达临界值的时候在阻止事件默认行为 1234567891011121314151617var startY,endY;//记录手指触摸的起点坐标$(&apos;body&apos;).on(&apos;touchstart&apos;,function (e) &#123; startY = e.touches[0].pageY;&#125;);$(&apos;body&apos;).on(&apos;touchmove&apos;,function (e) &#123; endY = e.touches[0].pageY; //记录手指触摸的移动中的坐标 //手指下滑，页面到达顶端不能继续下滑 if(endY&gt;startY&amp;&amp; $(window).scrollTop()&lt;=0)&#123; e.preventDefault(); &#125; //手指上滑，页面到达底部能继续上滑 if(endY&lt;startY&amp;&amp; $(window).scrollTop()+ $(window).height()&gt;=$(&apos;body&apos;)[0].scrollHeight)&#123; e.preventDefault(); &#125;&#125;) 有时也会碰见弹窗出来后两个层的橡皮筋效果出现问题，我们可以在弹出弹出时给底层页面加上一个类名，类名禁止页面滑动这样下层的橡皮筋效果就会被禁止，就不会影响弹窗层。 IOS机型margin属性无效问题？ 设置html body的高度为百分比时，margin-bottom在safari里失效 直接padding代替margin Ios绑定点击事件不执行？ 添加样式cursor ：pointer。点击后消除背景闪一下的css：-webkit-tap-highlight-color:transparent; Ios键盘换行变为搜索？ 首先，input 要放在 form里面。 这时 “换行” 已经变成 “前往”。 如果想变成 “搜索”，input 设置 type=”search”。 Jq对a标签点击事件不生效？出现这种情况的原因不明，有的朋友解释：我们平时都是点击的A标签中的文字了。 所以要想用JS模拟点击A标签事件，就得先往A标签中的文字添加能被JS捕获的元素，然后再用JS模拟点击该元素即可。但是我觉得不合理，虽然找不到原因但是解决办法还是有的。 (1)document.getElementById(“abc “).click(); (2)$(“#abc “)[0].click(); 有时因为服务器或者别的原因导致页面上的图片没有找到？这是我们想需要用一个本地的图片代替没有找的的图片 12345678&lt;script type=&quot;text/javascript&quot;&gt; function nofind()&#123; var img=event.srcElement; img.src=&quot;images/logoError.png&quot;; img.onerror=null; 控制不要一直跳动 &#125; &lt;/script&gt; &lt;img src=&quot;images/logo.png&quot; onerror=&quot;nofind();&quot; /&gt; transform属性影响position:fixed？ 规范中有规定：如果元素的transform值不为none，则该元素会生成包含块和层叠上下文。CSS Transforms Module Level 1不只在手机上，电脑上也一样。除了fixed元素会受影响之外，z-index（层叠上下文）值也会受影响。绝对定位元素等和包含块有关的属性都会受到影响。当然如果transform元素的display值为inline时又会有所不同。最简单的解决方法就是transform元素内部不能有absolute、fixed元素. ios对position: fixed不太友好，有时我们需要加点处理？在安卓上面，点击页面底部的输入框，软键盘弹出，页面移动上移。 而ios上面，点击页面底部输入框，软键盘弹出，输入框看不到了。。。查资料说什么的都有，iscroll,jquery-moblie，absolute，fixe，static都非常复杂，要改很多。。。 让他弹出时让滚动条在最低部 12345678910var u = navigator.userAgent, app = navigator.appVersion;var isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端if (isiOS) &#123; $(&apos;textarea&apos;).focus(function () &#123; window.setTimeout(&apos;scrollBottom()&apos;, 500); &#125;);&#125;function scrollBottom() &#123; window.scrollTo(0, $(&apos;body&apos;).height());&#125; jq validate插件验证问题？(1)所以的input必须有name不然会出错 有时手机会出现断网的情况，我没可能会对断网的情况做一些处理？(1)navigator.onLine可判断是否是脱机状态. 判断对象的长度？(1)用Object.keys，Object.keys方法返回的是一个数组，数组里面装的是对象的属性。 12345678910var person = &#123; &quot;name&quot; : &quot;itxcc&quot;, &quot;sex&quot; : &quot;man&quot;, &quot;age&quot; : &quot;50&quot;, &quot;height&quot; : &quot;180&quot;, &quot;phone&quot; : &quot;1xxxxxxxxxx&quot;, &quot;email&quot; : &quot;xxxxxxxxx@xxx.com&quot;&#125;;var arr = Object.keys(person);console.log(arr.length); (2)Object.getOwnPropertyNames(obj).length 上一题我们用到了Object.keys与Object.getOwnPropertyNames他们的区别？Object.keys定义：返回一个对象可枚举属性的字符串数组； Object.getOwnPropertyNames定义：返回一个对象可枚举、不可枚举属性的名称； 属性的可枚举性、不可枚举性：定义：可枚举属性是指那些内部 “可枚举” 标志设置为 true 的属性，对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true，对于通过 Object.defineProperty 等定义的属性，该标识值默认为 false。 123456var obj = &#123; &quot;prop1&quot;: &quot;v1&quot; &#125;;Object.defineProperty(obj, &quot;prop2&quot;, &#123; value: &quot;v2&quot;, enumerable: false &#125;);console.log(Object.keys(obj).length); //output：1console.log(Object.getOwnPropertyNames(obj).length); //output：2console.log(Object.keys(obj)); //output：Array[1] =&gt; [0: &quot;prop1&quot;]console.log(Object.getOwnPropertyNames(obj)); //output：Array[2] =&gt; [0: &quot;prop1&quot;, 1: &quot;prop2&quot;] 综合实例： 12345678910111213141516var obj = &#123; &quot;prop1&quot;: &quot;v1&quot; &#125;;Object.defineProperty(obj, &quot;prop2&quot;, &#123; value: &quot;v2&quot;, enumerable: false&#125;);console.log(obj.hasOwnProperty(&quot;prop1&quot;)); //output: trueconsole.log(obj.hasOwnProperty(&quot;prop2&quot;)); //output: trueconsole.log(obj.propertyIsEnumerable(&quot;prop1&quot;)); //output: trueconsole.log(obj.propertyIsEnumerable(&quot;prop2&quot;)); //output: falseconsole.log(&apos;prop1&apos; in obj); //output: trueconsole.log(&apos;prop2&apos; in obj); //output: truefor (var item in obj) &#123; console.log(item);&#125;//output：prop1for (var item in Object.getOwnPropertyNames(obj)) &#123; console.log(Object.getOwnPropertyNames(obj)[item]);&#125;//ouput:[prop1,prop2] 移动开发不同手机弹出数字键盘问题？(1)type=”tel” iOS和Android的键盘表现都差不多 (2)type=”number” 优点是Android下实现的一个真正的数字键盘 缺点一：iOS下不是九宫格键盘，输入不方便 缺点二：旧版Android（包括微信所用的X5内核）在输入框后面会有超级鸡肋的小尾巴，好在Android 4.4.4以后给去掉了。 不过对于缺点二，我们可以用webkit私有的伪元素给fix掉： 123456input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button &#123; -webkit-appearance: none; appearance: none; margin: 0; &#125; (3)pattern属性pattern用于验证表单输入的内容，通常HTML5的type属性，比如email、tel、number、data类、url等，已经自带了简单的数据格式验证功能了，加上pattern后，前端部分的验证更加简单高效了。 显而易见，pattern的属性值要用正则表达式。 实例 简单的数字验证 数字的验证有两个： 123&lt;input type=&quot;number&quot; pattern=&quot;d&quot;&gt; &lt;input type=&quot;number&quot; pattern=&quot;[0-9]*&quot;&gt; input[number]类型输入非数字字符js获取的值是空；比如-12，+123等 Javascript：history.go()和history.back()的用法与区别？简单的说就是：go(-1):返回上一页，原页面表单中的内容会丢失；back():返回上一页，原页表表单中的内容会保留。history.go(-1):后退+刷新history.back():后退 之所以注意到这个区别，是因为不同的浏览器后退行为也是有区别的，而区别就跟javascript：history.go()和history.back()的区别类似。 Chrome和ff浏览器后退页面，会刷新后退的页面，若有数据请求也会提交数据申请。类似于history.go(-1); 而safari（包括桌面版和ipad版）的后退按钮则不会刷新页面，也不会提交数据申请。类似于javascript：history.back(); Meta基础知识：123456789101112131415161718192021222324252627282930313233343536373839&lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;// width 设置viewport宽度，为一个正整数，或字符串‘device-width’// height 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置// initial-scale 默认缩放比例，为一个数字，可以带小数// minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数// maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数// user-scalable 是否允许手动缩放 空白页基本meta标签&lt;!-- 设置缩放 --&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, minimal-ui&quot; /&gt;&lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果） --&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;&lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;&lt;!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 --&gt;&lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no, email=no&quot; /&gt;其他meta标签&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;&lt;!-- 避免IE使用兼容模式 --&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; 移动端如何定义字体font-family？@ ————————————–中文字体的英文名称 @ 宋体 SimSun @ 黑体 SimHei @ 微信雅黑 Microsoft Yahei @ 微软正黑体 Microsoft JhengHei @ 新宋体 NSimSun @ 新细明体 MingLiU @ 细明体 MingLiU @ 标楷体 DFKai-SB @ 仿宋 FangSong @ 楷体 KaiTi @ 仿宋_GB2312 FangSong_GB2312 @ 楷体_GB2312 KaiTi_GB2312 @ @ 说明：中文字体多数使用宋体、雅黑，英文用Helvetica body { font-family: Microsoft Yahei,SimSun,Helvetica; } 打电话发短信写邮件怎么实现？12345678910111213141516171819202122// 一、打电话&lt;a href=&quot;tel:0755-10086&quot;&gt;打电话给:0755-10086&lt;/a&gt;// 二、发短信，winphone系统无效&lt;a href=&quot;sms:10086&quot;&gt;发短信给: 10086&lt;/a&gt;// 三、写邮件&lt;a href=&quot;mailto:863139978@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;//2.收件地址后添加?cc=开头，可添加抄送地址（Android存在兼容问题）&lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&quot;&gt;点击我发邮件&lt;/a&gt;//3.跟着抄送地址后，写上&amp;bcc=,可添加密件抄送地址（Android存在兼容问题）&lt;a href=&quot;mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=384900096@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;//4.包含多个收件人、抄送、密件抄送人，用分号(;)隔开多个邮件人的地址&lt;a href=&quot;mailto:863139978@qq.com;384900096@qq.com&quot;&gt;点击我发邮件&lt;/a&gt;//5.包含主题，用?subject=&lt;a href=&quot;mailto:863139978@qq.com?subject=邮件主题&quot;&gt;点击我发邮件&lt;/a&gt;//6.包含内容，用?body=;如内容包含文本，使用%0A给文本换行 &lt;a href=&quot;mailto:863139978@qq.com?body=邮件主题内容%0A腾讯诚信%0A期待您的到来&quot;&gt;点击我发邮件&lt;/a&gt;//7.内容包含链接，含http(s)://等的文本自动转化为链接&lt;a href=&quot;mailto:863139978@qq.com?body=http://www.baidu.com&quot;&gt;点击我发邮件&lt;/a&gt;//8.内容包含图片（PC不支持）&lt;a href=&quot;mailto:863139978@qq.com?body=&lt;img src=&apos;images/1.jpg&apos; /&gt;&quot;&gt;点击我发邮件&lt;/a&gt;//9.完整示例&lt;a href=&quot;mailto:863139978@qq.com;384900096@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=993233461@qq.com&amp;subject=[邮件主题]&amp;body=腾讯诚邀您参与%0A%0Ahttp://www.baidu.com%0A%0A&lt;img src=&apos;images/1.jpg&apos; /&gt;&quot;&gt;点击我发邮件&lt;/a&gt; 移动端touch事件（区分webkit和winphone）？// 以下支持webkit touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指 touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动 touchend——当手指离开屏幕时触发 touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用 //TouchEvent说明： touches：屏幕上所有手指的信息 targetTouches：手指在目标区域的手指信息 changedTouches：最近一次触发该事件的手指信息 touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息 //参数信息(changedTouches[0]) clientX、clientY在显示区的坐标 target：当前元素 //事件响应顺序 ontouchstart &gt; ontouchmove &gt; ontouchend &gt; onclick 点击元素产生背景或边框怎么去掉123456789101112//ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0去除灰色半透明遮罩；//android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果；//winphone系统,点击标签产生的灰色半透明背景，能通过设置&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;去掉；//特殊说明：有些机型去除不了，如小米2。对于按钮类还有个办法，不使用a或者input标签，直接用div标签 a,button,input,textarea &#123; -webkit-tap-highlight-color: rgba(0,0,0,0); -webkit-user-modify:read-write-plaintext-only; //-webkit-user-modify有个副作用，就是输入法不再能够输入多个字符&#125; // 也可以 * &#123; -webkit-tap-highlight-color: rgba(0,0,0,0); &#125;//winphone下&lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; 美化表单元素一、使用appearance改变webkit浏览器的默认外观 input,select { -webkit-appearance:none; appearance: none; } 二、winphone下，使用伪元素改变表单元素默认外观 1.禁用select默认箭头，::-ms-expand修改表单控件下拉箭头，设置隐藏并使用背景图片来修饰 1select::-ms-expand &#123; display:none; &#125; 2.禁用radio和checkbox默认样式，::-ms-check修改表单复选框或单选框默认图标，设置隐藏并使用背景图片来修饰 123input[type=radio]::-ms-check,input[type=checkbox]::-ms-check &#123; display:none; &#125; 3.禁用pc端表单输入框默认清除按钮，::-ms-clear修改清除按钮，设置隐藏并使用背景图片来修饰 12345input[type=text]::-ms-clear,input[type=tel]::-ms-clear,input[type=number]::-ms-clear &#123; display:none; &#125; 移动端字体单位font-size选择px还是rem？如需适配多种移动设备，建议使用rem。以下为参考值： html { font-size: 62.5%; } //10*16 = 62.5% 设置12px字体 这里注意在rem前要加上对应的px值，解决不支持rem的浏览器的兼容问题，做到优雅降级 body { font-size:12px; font-size:1.2rem; } input标签添加上disable属性在ios端字体颜色不兼容的问题？123456input[disabled],input:disabled,input.disabled&#123; color: #3e3e3e; -webkit-text-fill-color: #3e3e3e; -webkit-opacity:1; opacity: 1; &#125; IOS 的光标大小问题IE：不管该行有没有文字，光标高度与font-size一致。 FF：该行有文字时，光标高度与font-size一致。该行无文字时，光标高度与input的height一致。 Chrome：该行无文字时，光标高度与line-height一致；该行有文字时，光标高度从input顶部到文字底部(这两种情况都是在有设定line-height的时候)，如果没有line-height，则是与font-size一致。 IOS中情况和Chrome 相似。 设置字体大小和行高一致，然后通过 padding 撑开大小 只给IE浏览器设置 line-height -ms-line-height:40px; 转载自segmentfault作者键盘上的眼泪]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那时少年]]></title>
    <url>%2F2018%2F09%2F14%2F%E9%82%A3%E6%97%B6%E5%B0%91%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[只记得那时侯她很笨呐。 她会迷路，一旦离开我1000码的距离就会没有方向感，所以我学会了卡莉斯塔签订契约，她就不会走丢了。 她操作不好，被女警狙击的时候不会闪现到别人后面，所以我学会伊泽瑞尔的奥术越迁到她的面前，她就不会受伤了。 她胆子很小，只会玩奶妈型辅助躲在我后面加血，所以我学会格雷福斯的纯爷们多坚持一秒两秒，她就不用害怕了。 她也会有小脾气，输了游戏之后会沉默着一言不发，所以我学会薇恩后期拯救世界，她就会笑了吧。 她喜欢璐璐的可爱，我就用克格莫倾听皮克斯的细语； 她喜欢迦娜的轻柔，我就乘着崔丝塔娜的火箭坐上她的风； 她喜欢婕拉的蛮横，我就用韦鲁斯的藤蔓缠绕着她的种子生长； 她最喜欢拉克丝的随缘Q了，我会笑笑用艾希的魔法水晶箭打先手，这样她就不会空Q了。 她喜欢女警的大长腿。 她喜欢女枪开大时候的霸气。 她最喜欢薇恩了，她说她想玩薇恩。 我说好啊，我一个个教你。 她跑得慢，我就用塔姆吞了她一起跑； 她老是挨打，我就用布隆在她面前举起盾牌； 她被人贴脸了，我就用阿里斯塔的牛角疯狂地撞开敌人； 后来，她的薇恩终于超神了。 慢慢地，我走了。 她值得一个更好的人去保护她，而那个人不是我。 现在… 一个人玩AD，也挺好。 会漏刀了， 会抢人头了， 会卖队友了， 会自己买眼了。 一个人超神了，一个人超鬼了，都没人在乎了。 只是会很偶尔，碰到一个很胆小的索拉卡，小心翼翼地在后面加着血，生怕一不小心出了错，很像你。 却不是你。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建]]></title>
    <url>%2F2018%2F08%2F31%2Fhexo%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[hexo搭建学习笔记 搭建步骤 获得个人域名 GitHub创建个人仓库 安装Git 安装Node.js 安装hexo 推送网站 更换主题 发布文章 寻找图床 获取个人域名域名是网站的入口，也是网站的第一印象，比如小米的官网的域名是：https://www.mi.me/ ，很是巧妙。常见的有com,cn,net,org等后缀，也有小众的xyz,me,io等后缀，根据你自己的喜好，选择不同的后缀，比如我选择就是常见的com后缀。很多小众奇特的后缀在大陆是没办法备案的，网站也就无法上线。然而使用GitHub托管我们的网站，完全不需要备案，因为托管我们的网站内容的服务器在美国，而且在国内备案流程也比较繁杂，时间需要一周左右。 申请域名的地方有很多，这里推荐阿里云：阿里云-为了无法计算的价值 申请入口：域名注册 购买域名这也是我们整个搭建过程中惟一一个需要花钱的地方。如果你已经有了空闲域名就无需购买，直接使用即可。 GitHub创建个人仓库登录到GitHub,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号：Build software better, together 点击GitHub中的New repository创建新仓库，仓库名应该为：用户名.http://github.io 这个用户名使用你的GitHub帐号名称代替，这是固定写法，比如我的仓库名为：itxcc.github.io 安装Git什么是Git ?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。如果想要了解Git的细节，参看廖雪峰老师的Git教程：Git教程 从Git官网下载：Git - Downloading Package 现在的机子基本都是64位的，选择64位的安装包，下载后安装，在命令行里输入git测试是否安装成功，若安装失败，参看其他详细的Git安装教程。安装成功后，将你的Git与GitHub帐号绑定，鼠标右击打开Git Bash 或者在菜单里搜索Git Bash，设置user.name和user.email配置信息： 12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥文件： 1ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 然后直接三个回车即可，默认不需要设置密码然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制 打开GitHub_Settings_keys 页面，新建new SSH Key Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。在Git Bash中检测GitHub公钥设置是否成功，输入 ssh git@github.com ： 如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。 安装Node.jsHexo基于Node.js，Node.js下载地址：Download | Node.js 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v : 检测npm是否安装成功，在命令行中输入npm -v : 到这了，安装Hexo的环境已经全部搭建完成。 安装HexoHexo就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。创建好后，用git命令进入该文件夹： 使用npm命令安装Hexo，输入： 1npm install -g hexo-cli 这个安装时间较长耐心等待，安装完成后，初始化我们的博客，输入： 1hexo init blog 注意，这里的命令都是作用在刚刚创建的Blog文件夹中。 为了检测我们的网站雏形，分别按顺序输入以下三条命令： 12345hexo new test_my_sitehexo ghexo s 这些命令在后面作介绍，完成后，打开浏览器输入地址： localhost:4000 可以看到一个初始化hexo博客界面现在来介绍常用的Hexo 命令 123npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客 命令简写 12345678910hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 刚刚的三个命令依次是新建一篇博客文章、生成网页、在本地预览的操作。 推送网站上面只是在本地预览，接下来要做的就是就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件，如下图 进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件，如下图 下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：deploy:type: gitrepo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .gitbranch: master参考如下： 保存站点配置文件。 其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令： 1npm install hexo-deployer-git --save 这时，我们分别输入三条命令： 123hexo clean hexo g hexo d 其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 http://xxxx.github.io 你就会发现你的博客已经上线了，可以在网络上被访问了。 绑定域名虽然在Internet上可以访问我们的网站，但是网址是GitHub提供的:http://xxxx.github.io (知乎排版可能会出现”http://“字样) 而我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名。这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析 然后添加解析 包括添加三条解析记录，185.199.108.153是GitHub的地址，你也可以ping你的 http://xxxx.github.io 的ip地址，填入进去。第三个记录类型是CNAME，CNAME的记录值是：你的用户名.http://github.io 这里千万别弄错了。第二步，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名 点击save保存。第三步，进入本地博客文件夹 ，进入blog/source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。这里我还是写了www(不建议带有www): 完成这三步，进入blog目录中，按住shift键右击打开命令行，依次输入： 123hexo cleanhexo ghexo d 这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。 更换主题如果你不喜欢Hexo默认的主题，可以更换不同的主题，主题传送门：Themes 我自己使用的是Next主题，可以在blog目录中的themes文件夹中查看你自己主题是什么。现在把默认主题更改成Next主题，在blog目录中（就是命令行的位置处于blog目录）打开命令行输入： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 这是将Next主题下载到blog目录的themes主题下的next文件夹中。打开站点的_config.yml配置文件，修改主题为next 打开主题的_config.yml配置文件，不是站点主题文件，找到Scheme Settings next主题有四个样式，我用的是Pisces，你们可以自己试试看，选择你自己喜欢的样式（只需要把行首的#去除，#是注释），选择好后，再次部署网站，hexo g、hexo d，查看效果。选择其他主题，按照上述过程即可实现。 发布文章我们开始正式发布上线博客文章，在命令行中输入： 1hexo n &quot;博客名字&quot; 我们会发现在blog根目录下的source文件夹中的_post文件夹中多了一个 博客名字.md 文件，使用Markdown编辑器打开，就可以开始你的个人博客之旅了，Markdown常用的样式也就十来种，完全能够满足一般博文的样式要求通过带有预览样式的Markdown编辑器实时预览书写的博文样式，也可以通过命令 hexo s –debug 在本地浏览器的localhost:4000 预览博文效果。写好博文并且样式无误后，通过hexo g、hexo d 生成、部署网页。随后可以在浏览器中输入域名浏览。 寻找图床图床，当博文中有图片时，若是少量图片，可以直接把图片存放在source文件夹中，但这显然不合理的，因为图片会占据大量的存储的空间，加载的时候相对缓慢 ，这时考虑把博文里的图片上传到某一网站，然后获得外部链接，使用Markdown语法， 完成图片的插入，这种网站就被成为图床。常见的简易的图床网站有：贴图库图片外链 国内算比较好的图床我认为有两个：新浪微博和 七牛云 ，七牛云的使用方法可以参看其他文章。图床最重要的就是稳定速度快，所以在挑选图床的时候一定要仔细，下图是博文插入图片，使用图床外链的示例：]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信开放平台--网页扫码登录]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0--%E7%BD%91%E9%A1%B5%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[微信开放平台–网页扫码登录 做了一个最简单的微信网页扫码登录功能，记录一下整个过程 OAuth2.0 OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用 允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要分享他们的访问许可或他们数据的所有内容。 目标我们这里主要模拟使用OAuth2.0，用户通过扫描我们网页应用的二维码并进行授权登录来获取用户的基本信息的过程。详细的接口相关信息可以在微信开放平台上查看：https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;lang=zh_CN 前期准备（获取微信开发者权限） 在进行微信OAuth2.在进行微信OAuth2.0授权登录接入之前，在微信开放平台注册开发者帐号，并拥有一个已审核通过的网站应用，并获得相应的AppID和AppSecret，申请微信登录且通过审核后，可开始接入流程。 注册开发者账号可以在 https://open.weixin.qq.com/ 这里申请开发的账号。由于是腾讯的网页，这里可以直接通过 QQ号进行登录。 提交网站应用审核在已经登录的界面中选择“管理中心”——》网站应用——》创建网站应用 填写过后，还有有一个页面需要填写，提交一份纸质版申请书扫描件（会提供模板，我们下载再来填写后，需盖章，签名），配置回调域名（扫码登录后会跳转的页面）等。 之后提交审核即可，等微信审核通过，我们即可获得我们需要的网页应用的appid和AppSecret，并配置后回调的域名了（这三样是我们开发所必须的）。 开发者资质认证由于我们这里要使用微信登录的接口，所以我们还需要向微信提出认证，只有认证了才能使用微信那些高级的接口。未认证的如下图所示 认证之后是这样子的： 接下来，我们就可以开始我们的网页微信扫码登录开发了。 授权流程说明微信OAuth2.0授权登录让微信用户使用微信身份安全登录第三方应用或网站，在微信用户授权登录已接入微信OAuth2.0的第三方应用后，第三方可以获取到用户的接口调用凭证（access_token），通过access_token可以进行微信开放平台授权关系接口调用，从而可实现获取微信用户基本开放信息和帮助用户实现基础开放功能等。 微信OAuth2.0授权登录目前支持authorization_code模式，适用于拥有server端的应用授权。该模式整体流程为： 第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据code参数； 通过code参数加上AppID和AppSecret等，通过API换取access_token； 通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。 最后这一步可以结合微信开放平台官方文档进行操作。 https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;lang=zh_CN]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信开发</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery查找元素]]></title>
    <url>%2F2018%2F07%2F06%2Fjq%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[jQuery查找元素 12345678910111213141516171819jQuery.parent(expr) 找父亲节点，可以传入expr进行过滤，比如$(&quot;span&quot;).parent()或者$(&quot;span&quot;).parent(&quot;.class&quot;)jQuery.parents(expr),类似于jQuery.parents(expr),但是是查找所有祖先元素，不限于父元素jQuery.children(expr).返回所有子节点，这个方法只会返回直接的孩子节点，不会返回所有的子孙节点jQuery.contents(),返回下面的所有内容，包括节点和文本。这个方法和children()的区别就在于，包括空白文本，也会被作为一个jQuery对象返回，children()则只会返回节点jQuery.prev()，返回上一个兄弟节点，不是所有的兄弟节点jQuery.prevAll()，返回所有之前的兄弟节点jQuery.next(),返回下一个兄弟节点，不是所有的兄弟节点jQuery.nextAll()，返回所有之后的兄弟节点jQuery.siblings(),返回兄弟姐妹节点，不分前后jQuery.find(expr),跟jQuery.filter(expr)完全不一样。jQuery.filter()是从初始的jQuery对象集合中筛选出一部分，而jQuery.find()]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素居中的三种方法]]></title>
    <url>%2F2018%2F06%2F04%2F%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[元素居中的三种方法 1.12345678910111213141516171819202122232425div.box&#123;weight:200px;height:400px;&lt;!--把元素变成定位元素--&gt;position:absolute;&lt;!--设置元素的定位位置，距离上、左都为50%--&gt;left:50%;top:50%;&lt;!--设置元素的左外边距、上外边距为宽高的负1/2--&gt;margin-left:-100px;margin-top:-200px;&#125;*兼容性好;缺点:必须知道元素的宽高 2.1234567891011121314151617181920212223div.box&#123;weight:200px;height:400px;&lt;!--把元素变成定位元素--&gt;position:absolute;&lt;!--设置元素的定位位置，距离上、左都为50%--&gt;left:50%;top:50%;&lt;!--设置元素的相对于自身的偏移度为负50%(也就是元素自身尺寸的一半)--&gt;transform:translate(-50%,-50%);&#125;*这是css3里的样式;缺点:兼容性不好，只支持IE9+的浏览器 3.12345678910111213.dialog_container:after &#123;display: inline-block;content: ”;width: 0;height: 100%;vertical-align: middle;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript--setTimeout与setInterval区别]]></title>
    <url>%2F2018%2F01%2F25%2FJavascript--setTimeout%E4%B8%8EsetInterval%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Javascript–setTimeout与setInterval区别 javascript中settimeout和setinterval的区别是settimeout只运行一次，也就是说设定的时间到后就触发运行指定代码，运行完后即结束。如果运行的代码中再次运行同样的settimeout命令，则可循环运行。 setinterval是循环运行的，即每到设定时间间隔就触发指定代码。这是真正的定时器。setinterval使用简单，而settimeout则比较灵活，可以随时退出循环，而且可以设置为按不固定的时间间隔来运行，比如第一次1秒，第二次2秒，第三次3秒…… settimeout详解var t = settimeout(“javascript 语句”, 时间参数) 注：时间参数单位为毫秒 示例：var t=settimeout(“alert(’3 seconds!’)”, 3000) 如果js语句带变量，则必须用+号将变量连接起来，如： var t = settimeout（”document.getelementbyid(“+menuid+”).style.display=’none’”, 3000) cleartimeout详解 语法：cleartimeout(settimeout的变量名) 示例：cleartimeout(t) //其中t为前面设置的settimeout的变量 使用cleartimeout可以随时停止计时。 setinterval定义和用法setinterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。 setinterval() 方法会不停地调用函数，直到 clearinterval() 被调用或窗口被关闭。由 setinterval() 返回的 id 值可用作 clearinterval() 方法的参数。 语法 setinterval(code,millisec[,”lang”]) 参数 描述 code 必需。要调用的函数或要执行的代码串。 millisec 必须。周期性执行或调用 code 之间的时间间隔，以毫秒计。 返回值 一个可以传递给 window.clearinterval() 从而取消对 code 的周期性执行的值。 例如： 123456var int=self.setinterval("clock()", 50) function clock()&#123; var t=new date() document.getelementbyid("clock").value = t &#125;&lt;button onclick="int=window.clearinterval(int)"&gt;stop interval&lt;/button&gt; 深度了解settimeout和setinterval的区别settimeout和setinterval这两个函数, 大家肯定都不陌生, 但可能并不是每个用过这两个方法的同学, 都了解其内部的实质。甚至可能会错误的把两个实现定时调用的函数理解成了类似thread一样的东西, 认为会在一个时间片内, 并发的执行调用的函数, 似乎很好很强大, 但其实并不是如此, 实际的情况是javascript都是以单线程的方式运行于浏览器的javascript引擎中的, settimeout和setinterval的作用只是把你要执行的代码在你设定的一个时间点插入js引擎维护的一个代码队列中, 插入代码队列并不意味着你的代码就会立马执行的,理解这一点很重要. 而且settimeout和setinterval还有点不一样。 __先谈谈setTimeout __ 假设我们给一个button的onclick事件绑定了此方法, 当我们按下按钮后, 肯定先执行block1的内容, 然后运行到setTimeout的地方, setTimeout会告诉浏览器说, “200ms后我会插一段要执行的代码给你的队列中”, 浏览器当然答应了(注意插入代码并不意味着立马执行), setTimeout代码运行后, 紧跟其后的block2代码开始执行, 这里就开始说明问题了, 如果block2的代码执行时间超过200ms, 那结果会是如何? 或许按照你之前的理解, 会理所当然的认为200ms一到, 你的process代码会立马执行…事实是, 在block2执行过程中(执行了200ms后)process代码被插入代码队列, 但一直要等click方法执行结束, 才会执行process代码段, 从代码队列上看process代码是在click后面的, 再加上js以单线程方式执行, 所以应该不难理解. 如果是另一种情况, block2代码执行的时间&lt;200ms, setTimeout在200ms后将process代码插入到代码队列, 而那时执行线程可能已经处于空闲状态了(idle), 那结果就是200ms后, process代码插入队列就立马执行了, 就让你感觉200ms后, 就执行了. __再看看setInterval __ 这里可能会存在两个问题: 1.时间间隔或许会跳过 2.时间间隔可能&lt;定时调用的代码的执行时间 1234567function click() &#123; // code block1... setInterval(function() &#123; // process ... &#125;, 200); // code block2 &#125; 和上面一样我们假设通过一个click, 触发了setInterval以实现每隔一个时间段执行process代码 比如onclick要300ms执行完, block1代码执行完, 在5ms时执行setInterval, 以此为一个时间点, 在205ms时插入process代码, click代码顺利结束, process代码开始执行(相当于图中的timer code), 然而process代码也执行了一个比较长的时间, 超过了接下来一个插入时间点405ms, 这样代码队列后又插入了一份process代码, process继续执行着, 而且超过了605ms这个插入时间点, 下面问题来, 可能你还会认为代码队列后面又会继续插入一份process代码…真实的情况是,由于代码队列中已经有了一份未执行的process代码, 所以605ms这个插入时间点将会被”无情”的跳过, 因为js引擎只允许有一份未执行的process代码, 说到这里不知道您是不是会豁然开朗呢… 为了这种情况你可以用一种更好的代码形式 1234setTimeout(function()&#123; //processing setTimeout(arguments.callee, interval); &#125;, interval);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>

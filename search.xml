<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTML5语义化标签笔记</title>
      <link href="/2019/01/18/HTML5%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/18/HTML5%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>HTML5语义化标签笔记</p><a id="more"></a><h3 id="为什么会有h5-语义化标签"><a href="#为什么会有h5-语义化标签" class="headerlink" title="为什么会有h5 语义化标签"></a>为什么会有h5 语义化标签</h3><p>在HTML5出现之前，我们一般采用DIV+CSS布局页面。但是这样的布局方式不仅使我们的文档结构不够清晰，而且不利于搜索引擎爬虫对我们页面的爬取。为了解决上述缺点，HTML5新增了很多新的语义化标签。</p><h3 id="语义标签的概念"><a href="#语义标签的概念" class="headerlink" title="语义标签的概念"></a>语义标签的概念</h3><p><strong>维基百科</strong></p><p><code>语义化</code>是前端开发里面的一个专用术语，其优点在于标签语义化有助于构架良好的<a href="https://zh.wikipedia.org/wiki/Html" target="_blank" rel="noopener">html</a>结构，有利于<a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E" target="_blank" rel="noopener">搜索引擎</a>的建立索引、抓取；另外，亦有利于页面在不同的设备上显示尽可能相同；此外，亦有利于构建清晰的机构，有利于团队的开发、维护。</p><p>通俗来说：语义化的意思是从名称一眼就能看出其内容和作用是什么，语义化标签就是通过使用浅显易懂的元素名和属性名来实现语义化的</p><h3 id="语义标签有什么用？"><a href="#语义标签有什么用？" class="headerlink" title="语义标签有什么用？"></a>语义标签有什么用？</h3><ul><li>可以提高页面的可访问性，即在css丢失的情况下，页面结构仍然可以比较清晰的展现；</li><li>提高用户体验，用户不够清楚地方可以得到良好的解释；</li><li>有利于页面seo，让搜索引擎更容易明白页面结构和内容的主次顺序；</li><li>有利于页面维护者理解代码结构，降低维护成本；</li><li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页</li></ul><h3 id="常用语义标签有哪些？"><a href="#常用语义标签有哪些？" class="headerlink" title="常用语义标签有哪些？"></a>常用语义标签有哪些？</h3><p><strong>h1到h6标签 表示不同等级的标题</strong></p><ul><li>可以用来表现文本内容的层级结构</li></ul><p><strong><code>&lt;article&gt;</code> 元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构</strong></p><ul><li><code>&lt;article&gt;</code> 可以嵌套使用，但是他们必须是部分与整体的关系</li><li><code>&lt;article&gt;</code> 元素的作者信息可通过 <code>&lt;address&gt;</code> 元素提供，但是不适用于嵌套的 <code>&lt;article&gt;</code> 元素</li><li><code>&lt;article&gt;</code> 元素的发布日期和时间可通过 <code>&lt;time&gt;</code> 元素的pubdate属性表示</li></ul><p><strong><aside>定义侧栏标签</aside></strong></p><ul><li>如果使用多个 <code>&lt;aside&gt;</code>，标签应该在主要内容的后面，这样有利于SEO的搜索与提升可访问性</li><li>如果是与文章的主要内容有关系的图像需要用 <code>&lt;figure&gt;</code> 标签代替</li></ul><p><strong><code>&lt;section&gt;</code> 元素表示文档中的一个区域（或节），比如，内容中的一个专题组，一般来说会有包含一个标题（heading）</strong></p><ul><li>如果元素内容可以分为几个部分的话，应该使用 <code>&lt;article&gt;</code> 而不是 <code>&lt;section&gt;</code></li><li>不要把 <code>&lt;section&gt;</code> 元素作为一个普通的容器来使用。 一般来说，一个 <code>&lt;section&gt;</code> 应该出现在文档大纲中</li></ul><p><strong><code>&lt;header&gt;</code> 元素用来表示一些前言性质或导航类的内容。它可以包含一些标题性质元素，也可以放置一些比如logo，搜索框，或其它的 <code>&lt;header&gt;</code> 元素等</strong></p><ul><li><code>&lt;header&gt;</code> 元素并不是一个可以形成段落内容的元素，所以，不需要在内容目录里体现出来</li></ul><p><strong><code>&lt;footer&gt;</code> 元素表示最近一个章节内容或者根节点（sectioning root）元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息</strong></p><ul><li><code>&lt;footer&gt;</code> 元素内的作者信息应包含在 <code>&lt;address&gt;</code> 元素中</li><li><code>&lt;footer&gt;</code> 元素不是章节内容，因此在outline中不能包含新的章节</li></ul><p><strong><code>&lt;nav&gt;</code> 描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表</strong></p><ul><li>并不是所有的链接都必须使用 <code>&lt;nav&gt;</code> 元素,它只用来将一些热门的链接放入导航栏</li><li>一个网页也可能含有多个 <code>&lt;nav&gt;</code> 元素,例如一个是网站内的导航列表,另一个是本页面内的导航列表</li><li>对于屏幕阅读障碍的人,可以使用这个元素来确定是否忽略初始内容</li></ul><p><strong><code>&lt;dl&gt;,&lt;dt&gt;,&lt;dd&gt;</code> (自定义列表)</strong></p><ul><li>dl: 英文意思为definition list，作用是定义列表</li><li>dt: 英文意思为defines terms，作用是定义列表中的项目</li><li>dd: 英文意思为defines description，作用是定义列表中项目的注释</li></ul><p><strong><code>&lt;b&gt;/&lt;strong&gt;</code> 元素默认均展示为加粗</strong></p><ul><li><code>&lt;b&gt;</code> 表示“文体突出”文字，通俗讲就是突出不安分的文字。像概要中的关键字，产品名。或者代表强调的排版方式</li><li><code>&lt;strong&gt;</code> 表示重程度的强调</li></ul><p><strong><code>&lt;i&gt;/&lt;em&gt;</code> 元素默认均展示为斜体</strong></p><ul><li><code>&lt;i&gt;</code> 表现为在文章中突出不同意见或语气或的一段文本,例如外语，科技术语、或者是排版用的斜体文字</li><li><code>&lt;em&gt;</code> 表示强调</li></ul><p><strong><code>&lt;mark&gt;</code>用来突出显示文本，他的效果就像是用荧光笔给重点的语句做标一样</strong></p><p><strong><code>&lt;address&gt;</code> 元素可以让作者为它最近的 <code>&lt;article&gt;</code> 或者 <code>&lt;body&gt;</code> 祖先元素提供联系信息。在后一种情况下，它应用于整个文档</strong></p><ul><li>当表示一个和联系信息无关的任意的地址时，应使用 <code>&lt;p&gt;</code> 元素</li><li>这个元素不能包含除了联系信息之外的任何信息，比如出版日期</li><li>通常，<code>&lt;address&gt;</code> 元素可以放在当前section的 <code>&lt;footer&gt;</code> 元素中，如果存在的话</li></ul><p><strong><code>&lt;figure&gt;</code> 这个元素是用来引入图表、图形、照片等，对应的场景就是像是杂志中的图片一样</strong></p><ul><li><code>&lt;figure&gt;</code> 元素可以包含多个内容块，但是只能有一个 <code>&lt;figcaption&gt;</code>（可以理解成给图表加标题）标签</li><li>可以用 <code>&lt;h1&gt; ~ &lt;h6&gt;</code> 来给 <code>&lt;figure&gt;</code> 增加标题；</li><li><code>&lt;figcaption&gt;</code> 不能单独出现，需要有配套的内容一起出现</li></ul><p><strong><code>&lt;time&gt;</code> 可以通过这个标签标记一个具体的时间或日期，应用场景通常就是一篇文章的发表时间</strong></p><ul><li>datetime中的时间最好与 <code>&lt;time&gt;</code> 标签中的文本元素日期一样，写法可以不一样</li><li>如果这个时间是代表整个文章或是页面的时间需要添加pubdate属性</li><li>不要在 <code>&lt;time&gt;</code> 标签中使用不确切的时间如：“今天中午”、“上周末”</li><li>如果 使用pubdate属性需要注意的是要在同一个父标签下面不要出现张冠李戴的问题</li><li><code>&lt;time&gt;</code> 标签不能在嵌套另一个 <code>&lt;time&gt;</code> 标签</li><li>datatime中的时间格式需要是标准的机器可能的时间 如:YYYY-MM-DDThh:mm:ss</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>尽可能少的使用无语义的标签div和span</li><li>在语义不明显时，既可以使用div或者p时，尽量用p，因为p在默认情况下有上下间距，对兼容特殊终端有利</li><li>使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td</li><li>表单域要用fieldset标签包起来，并用legend标签说明表单的用途</li><li>每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习笔记</title>
      <link href="/2018/10/21/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/21/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>git学习笔记</p><a id="more"></a><blockquote><p>从svn转到git版本控制之后，就爱上了它，再配合上github，简直不要太爽,以下是结合多方查询之后，总结出来适用于自己的git笔记！</p></blockquote><hr><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="配置账号信息"><a href="#配置账号信息" class="headerlink" title="配置账号信息"></a>配置账号信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git config -e [--global]  #编辑Git配置文件</span><br><span class="line"></span><br><span class="line">git config --global user.name itxcc</span><br><span class="line">git config --global user.email itxcc420@gmail.com</span><br><span class="line"></span><br><span class="line">git config --list #查看配置的信息</span><br><span class="line"></span><br><span class="line">git help config #获取帮助信息</span><br></pre></td></tr></table></figure><h4 id="配置密钥"><a href="#配置密钥" class="headerlink" title="配置密钥"></a>配置密钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C itxccc420@gmail.com #生成密钥</span><br><span class="line"></span><br><span class="line">ssh -T git@github.com #测试是否成功</span><br></pre></td></tr></table></figure><h4 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status #git st</span><br><span class="line">git config --global alias.co checkout #git co</span><br><span class="line">git config --global alias.br branch #git br</span><br><span class="line">git config --global alias.ci commit #git ci</span><br></pre></td></tr></table></figure><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">git init #初始化</span><br><span class="line"></span><br><span class="line">git status #文件状态</span><br><span class="line"></span><br><span class="line">git add [file1] [file2] ... #.或*代表全部添加</span><br><span class="line"></span><br><span class="line">git commit -m &quot;msessage&quot; </span><br><span class="line">备注：</span><br><span class="line">-  type（文件）：‘备注’</span><br><span class="line">- - feat:新功能</span><br><span class="line">- - fix:修复bug</span><br><span class="line">- - style：格式</span><br><span class="line">- - refactor：代码重构</span><br><span class="line">- - chore：项目构建</span><br><span class="line"></span><br><span class="line">git push origin 分支名称  #推送到某个分支</span><br><span class="line"></span><br><span class="line">git log #查看所有提交记录</span><br><span class="line">git reflog #不小心删除了东西，先查到commit id，恢复</span><br><span class="line"></span><br><span class="line">git branch #显示所有本地分支</span><br><span class="line">git branch test #新建test分支</span><br><span class="line">git push git test #推送test分支到远程</span><br><span class="line">git checout test #切换到test分支</span><br><span class="line">git merge test #将test分支合并到当前分支</span><br><span class="line">git branch -d test #删除test分支</span><br><span class="line">git push origin -d test #删除远程test分支</span><br><span class="line"></span><br><span class="line">git rebase master#将master分之上超前的提交，变基到当前分支</span><br><span class="line">git rebase --onto master 169a6 #限制回滚范围，rebase当前分支从169a6以后的提交</span><br><span class="line">git rebase --interactive #交互模式</span><br><span class="line">git rebase --continue# 处理完冲突继续合并</span><br><span class="line">git rebase --skip# 跳过</span><br><span class="line">git rebase --abort# 取消合并</span><br><span class="line"></span><br><span class="line">git tag #列出现有标签</span><br><span class="line"></span><br><span class="line">git tag v0.1 [branch|commit] # [从指定位置]新建标签</span><br><span class="line">git tag -a v0.1 -m &apos;my version 1.4&apos;#新建带注释标签</span><br><span class="line"></span><br><span class="line">git checkout tagname#切换到标签</span><br><span class="line"></span><br><span class="line">git push origin v1.5#推送分支到源上</span><br><span class="line">git push origin --tags#一次性推送所有分支</span><br><span class="line"></span><br><span class="line">git tag -d v0.1#删除标签</span><br><span class="line">git push origin :refs/tags/v0.1#删除远程标签</span><br></pre></td></tr></table></figure><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><ul><li>一般而言，会有两个公共分支<br>&nbsp;&nbsp;&nbsp;&nbsp;master （项目主分支）<br>&nbsp;&nbsp;&nbsp;&nbsp;dev （测试分支）</li><li>开发一般是需要在自己的分支进行开发，然后推送到远端，本地则需要git merge 本地分支来进行更新dev分支，如果是多人开发，则需要git pull来更新dev分支</li><li>在开发需要下拉代码时，远程仓库和本地刚好又有改动，最好先将自己在本地的代码进行 git stash （暂存区），再去进行下拉，在运行git stash pop 把自己的代码释放出来</li><li>添加tag<br>  &nbsp;&nbsp;&nbsp;&nbsp;git tag -a v0.0.0 -m ‘v0.0.0’<br>  &nbsp;&nbsp;&nbsp;&nbsp;git push – tag</li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建</title>
      <link href="/2018/08/31/hexo%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/08/31/hexo%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>hexo搭建学习笔记</p><a id="more"></a><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ul><li>获得个人域名</li><li>GitHub创建个人仓库</li><li>安装Git</li><li>安装Node.js</li><li>安装hexo</li><li>推送网站</li><li>更换主题</li><li>发布文章</li><li>寻找图床</li></ul><h3 id="获取个人域名"><a href="#获取个人域名" class="headerlink" title="获取个人域名"></a>获取个人域名</h3><p>域名是网站的入口，也是网站的第一印象，比如小米的官网的域名是：<a href="https://www.mi.me/" target="_blank" rel="noopener">https://www.mi.me/</a> ，很是巧妙。常见的有com,cn,net,org等后缀，也有小众的xyz,me,io等后缀，根据你自己的喜好，选择不同的后缀，比如我选择就是常见的com后缀。很多小众奇特的后缀在大陆是没办法备案的，网站也就无法上线。然而使用GitHub托管我们的网站，完全不需要备案，因为托管我们的网站内容的服务器在美国，而且在国内备案流程也比较繁杂，时间需要一周左右。</p><p>申请域名的地方有很多，这里推荐阿里云：阿里云-为了无法计算的价值 申请入口：域名注册 购买域名这也是我们整个搭建过程中惟一一个需要花钱的地方。如果你已经有了空闲域名就无需购买，直接使用即可。</p><h3 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h3><p>登录到GitHub,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号：Build software better, together 点击GitHub中的New repository创建新仓库，仓库名应该为：用户名.<a href="http://github.io" target="_blank" rel="noopener">http://github.io</a> 这个用户名使用你的GitHub帐号名称代替，这是固定写法，比如我的仓库名为：<a href="http://www.itxcc.com/" target="_blank" rel="noopener">itxcc.github.io</a></p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>什么是Git ?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。如果想要了解Git的细节，参看廖雪峰老师的Git教程：Git教程 从Git官网下载：Git - Downloading Package 现在的机子基本都是64位的，选择64位的安装包，下载后安装，在命令行里输入git测试是否安装成功，若安装失败，参看其他详细的Git安装教程。安装成功后，将你的Git与GitHub帐号绑定，鼠标右击打开Git Bash</p><p><img src="http://img.itxcc.com/blog/180917/E0jBigDkGl.jpg?imageslim" alt="mark"></p><p>或者在菜单里搜索Git Bash，设置user.name和user.email配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure><p>生成ssh密钥文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure><p>然后直接三个回车即可，默认不需要设置密码<br>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制</p><p><img src="http://img.itxcc.com/blog/180917/bElEm0b7mK.png?imageslim" alt="mark"></p><p>打开<a href="https://github.com/settings/keys" target="_blank" rel="noopener">GitHub_Settings_keys</a> 页面，新建new SSH Key</p><p><img src="http://img.itxcc.com/blog/180917/bB0lKa2F3D.png?imageslim" alt="mark"></p><p>Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。<br>在Git Bash中检测GitHub公钥设置是否成功，输入 ssh <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a> ：</p><p><img src="http://img.itxcc.com/blog/180917/D7heKL55DF.png?imageslim" alt="mark"></p><p>如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。</p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>Hexo基于Node.js，Node.js下载地址：Download | Node.js 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v :</p><p><img src="http://img.itxcc.com/blog/180917/289GJjcaiG.png?imageslim" alt="mark"></p><p>检测npm是否安装成功，在命令行中输入npm -v :</p><p><img src="http://img.itxcc.com/blog/180917/h88jGFDCk0.png?imageslim" alt="mark"></p><p>到这了，安装Hexo的环境已经全部搭建完成。</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>Hexo就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。创建好后，用git命令进入该文件夹：</p><p>使用npm命令安装Hexo，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>这个安装时间较长耐心等待，安装完成后，初始化我们的博客，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>注意，这里的命令都是作用在刚刚创建的Blog文件夹中。</p><p>为了检测我们的网站雏形，分别按顺序输入以下三条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new test_my_site</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>这些命令在后面作介绍，完成后，打开浏览器输入地址：</p><p>localhost:4000</p><p>可以看到一个初始化hexo博客界面<br>现在来介绍常用的Hexo 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g #安装Hexo</span><br><span class="line">npm update hexo -g #升级</span><br><span class="line">hexo init #初始化博客</span><br></pre></td></tr></table></figure><p>命令简写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章</span><br><span class="line">hexo g == hexo generate #生成</span><br><span class="line">hexo s == hexo server #启动服务预览</span><br><span class="line">hexo d == hexo deploy #部署</span><br><span class="line"></span><br><span class="line">hexo server #Hexo会监视文件变动并自动更新，无须重启服务器</span><br><span class="line">hexo server -s #静态模式</span><br><span class="line">hexo server -p 5000 #更改端口</span><br><span class="line">hexo server -i 192.168.1.1 #自定义 IP</span><br><span class="line">hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</span><br></pre></td></tr></table></figure><p>刚刚的三个命令依次是新建一篇博客文章、生成网页、在本地预览的操作。</p><h3 id="推送网站"><a href="#推送网站" class="headerlink" title="推送网站"></a>推送网站</h3><p>上面只是在本地预览，接下来要做的就是就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件，如下图</p><p><img src="http://img.itxcc.com/blog/180917/3iFb7ALk32.png?imageslim" alt="mark"></p><p>进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件，如下图</p><p><img src="http://img.itxcc.com/blog/180917/KE4607E9EB.png?imageslim" alt="mark"></p><p>下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：<br>deploy:<br>type: git<br>repo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .git<br>branch: master参考如下：</p><p><img src="http://img.itxcc.com/blog/180917/CGLgIDIClm.png?imageslim" alt="mark"></p><p>保存站点配置文件。</p><p>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>这时，我们分别输入三条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 <a href="http://xxxx.github.io" target="_blank" rel="noopener">http://xxxx.github.io</a> </p><p>你就会发现你的博客已经上线了，可以在网络上被访问了。</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>虽然在Internet上可以访问我们的网站，但是网址是GitHub提供的:<a href="http://xxxx.github.io" target="_blank" rel="noopener">http://xxxx.github.io</a> (知乎排版可能会出现”http://“字样) 而我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名。这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析</p><p><img src="http://img.itxcc.com/blog/180917/7aF0G3haIh.png?imageslim" alt="mark"></p><p>然后添加解析</p><p><img src="http://img.itxcc.com/blog/180917/f8Gm7lCgDE.png?imageslim" alt="mark"></p><p>包括添加三条解析记录，185.199.108.153是GitHub的地址，你也可以ping你的 <a href="http://xxxx.github.io" target="_blank" rel="noopener">http://xxxx.github.io</a> 的ip地址，填入进去。第三个记录类型是CNAME，CNAME的记录值是：你的用户名.<a href="http://github.io" target="_blank" rel="noopener">http://github.io</a> 这里千万别弄错了。第二步，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名</p><p><img src="http://img.itxcc.com/blog/180917/ilHgjhhK3B.png?imageslim" alt="mark"></p><p>点击save保存。第三步，进入本地博客文件夹 ，进入blog/source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。这里我还是写了www(不建议带有www):</p><p><img src="http://img.itxcc.com/blog/180917/FDBKC46l5K.png?imageslim" alt="mark"></p><p>完成这三步，进入blog目录中，按住shift键右击打开命令行，依次输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。</p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>如果你不喜欢Hexo默认的主题，可以更换不同的主题，主题传送门：Themes 我自己使用的是Next主题，可以在blog目录中的themes文件夹中查看你自己主题是什么。现在把默认主题更改成Next主题，在blog目录中（就是命令行的位置处于blog目录）打开命令行输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>这是将Next主题下载到blog目录的themes主题下的next文件夹中。打开站点的_config.yml配置文件，修改主题为next</p><p><img src="http://img.itxcc.com/blog/180917/01k7G2EFAG.png?imageslim" alt="mark"></p><p>打开主题的_config.yml配置文件，不是站点主题文件，找到Scheme Settings</p><p><img src="http://img.itxcc.com/blog/180917/geBe9EGKcA.png?imageslim" alt="mark"></p><p>next主题有四个样式，我用的是Pisces，你们可以自己试试看，选择你自己喜欢的样式（只需要把行首的#去除，#是注释），选择好后，再次部署网站，hexo g、hexo d，查看效果。选择其他主题，按照上述过程即可实现。</p><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>我们开始正式发布上线博客文章，在命令行中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;博客名字&quot;</span><br></pre></td></tr></table></figure><p>我们会发现在blog根目录下的source文件夹中的_post文件夹中多了一个 博客名字.md 文件，使用Markdown编辑器打开，就可以开始你的个人博客之旅了，Markdown常用的样式也就十来种，完全能够满足一般博文的样式要求<br>通过带有预览样式的Markdown编辑器实时预览书写的博文样式，也可以通过命令 hexo s –debug 在本地浏览器的localhost:4000 预览博文效果。写好博文并且样式无误后，通过hexo g、hexo d 生成、部署网页。随后可以在浏览器中输入域名浏览。</p><h3 id="寻找图床"><a href="#寻找图床" class="headerlink" title="寻找图床"></a>寻找图床</h3><p>图床，当博文中有图片时，若是少量图片，可以直接把图片存放在source文件夹中，但这显然不合理的，因为图片会占据大量的存储的空间，加载的时候相对缓慢 ，这时考虑把博文里的图片上传到某一网站，然后获得外部链接，使用Markdown语法，<img src="%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5" alt="图片信息"> 完成图片的插入，这种网站就被成为图床。常见的简易的图床网站有：贴图库图片外链 国内算比较好的图床我认为有两个：新浪微博和 七牛云 ，七牛云的使用方法可以参看其他文章。图床最重要的就是稳定速度快，所以在挑选图床的时候一定要仔细，下图是博文插入图片，使用图床外链的示例：</p><p><img src="http://img.itxcc.com/blog/180917/Kf64eFJ605.png?imageslim" alt="mark"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信开放平台--网页扫码登录</title>
      <link href="/2018/08/21/%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0--%E7%BD%91%E9%A1%B5%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/"/>
      <url>/2018/08/21/%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0--%E7%BD%91%E9%A1%B5%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>微信开放平台–网页扫码登录</p> <a id="more"></a><blockquote><p>做了一个最简单的微信网页扫码登录功能，记录一下整个过程</p></blockquote><h2 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h2><ul><li>OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用</li><li>允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要分享他们的访问许可或他们数据的所有内容。</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>我们这里主要模拟使用OAuth2.0，用户通过扫描我们网页应用的二维码并进行授权登录来获取用户的基本信息的过程。详细的接口相关信息可以在微信开放平台上查看：<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;lang=zh_CN" target="_blank" rel="noopener">https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;lang=zh_CN</a></p><h2 id="前期准备（获取微信开发者权限）"><a href="#前期准备（获取微信开发者权限）" class="headerlink" title="前期准备（获取微信开发者权限）"></a>前期准备（获取微信开发者权限）</h2><p>　在进行微信OAuth2.在进行微信OAuth2.0授权登录接入之前，在微信开放平台注册开发者帐号，并拥有一个已审核通过的网站应用，并获得相应的AppID和AppSecret，申请微信登录且通过审核后，可开始接入流程。</p><h3 id="注册开发者账号"><a href="#注册开发者账号" class="headerlink" title="注册开发者账号"></a>注册开发者账号</h3><p>可以在 <a href="https://open.weixin.qq.com/" target="_blank" rel="noopener">https://open.weixin.qq.com/</a> 这里申请开发的账号。由于是腾讯的网页，这里可以直接通过 QQ号进行登录。</p><h3 id="提交网站应用审核"><a href="#提交网站应用审核" class="headerlink" title="提交网站应用审核"></a>提交网站应用审核</h3><p>在已经登录的界面中选择“管理中心”——》网站应用——》创建网站应用</p><p><img src="http://img.itxcc.com/blog/180920/41dbDKeJmg.png?imageslim" alt="mark"></p><p>填写过后，还有有一个页面需要填写，提交一份纸质版申请书扫描件（会提供模板，我们下载再来填写后，需盖章，签名），配置回调域名（扫码登录后会跳转的页面）等。</p><p>之后提交审核即可，等微信审核通过，我们即可获得我们需要的网页应用的appid和AppSecret，并配置后回调的域名了（这三样是我们开发所必须的）。</p><h3 id="开发者资质认证"><a href="#开发者资质认证" class="headerlink" title="开发者资质认证"></a>开发者资质认证</h3><p>由于我们这里要使用微信登录的接口，所以我们还需要向微信提出认证，只有认证了才能使用微信那些高级的接口。未认证的如下图所示<br><img src="http://img.itxcc.com/blog/180920/bhGAdmAF42.png?imageslim" alt="mark"></p><p>认证之后是这样子的：</p><p><img src="http://img.itxcc.com/blog/180920/127kG53If7.png?imageslim" alt="mark"></p><p>接下来，我们就可以开始我们的网页微信扫码登录开发了。</p><h3 id="授权流程说明"><a href="#授权流程说明" class="headerlink" title="授权流程说明"></a>授权流程说明</h3><p>微信OAuth2.0授权登录让微信用户使用微信身份安全登录第三方应用或网站，在微信用户授权登录已接入微信OAuth2.0的第三方应用后，第三方可以获取到用户的接口调用凭证（access_token），通过access_token可以进行微信开放平台授权关系接口调用，从而可实现获取微信用户基本开放信息和帮助用户实现基础开放功能等。 </p><p>　　微信OAuth2.0授权登录目前支持authorization_code模式，适用于拥有server端的应用授权。该模式整体流程为：</p><ul><li>第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据code参数；</li><li>通过code参数加上AppID和AppSecret等，通过API换取access_token；</li><li>通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。</li></ul><p>最后这一步可以结合微信开放平台官方文档进行操作。</p><p><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;lang=zh_CN" target="_blank" rel="noopener">https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;lang=zh_CN</a></p>]]></content>
      
      
      <categories>
          
          <category> 微信开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 微信开发 </tag>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery查找元素</title>
      <link href="/2018/07/06/jq%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0/"/>
      <url>/2018/07/06/jq%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>jQuery查找元素</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">jQuery.parent(expr) 找父亲节点，可以传入expr进行过滤，比如$(&quot;span&quot;).parent()或者$(&quot;span&quot;).parent(&quot;.class&quot;)</span><br><span class="line"></span><br><span class="line">jQuery.parents(expr),类似于jQuery.parents(expr),但是是查找所有祖先元素，不限于父元素</span><br><span class="line"></span><br><span class="line">jQuery.children(expr).返回所有子节点，这个方法只会返回直接的孩子节点，不会返回所有的子孙节点</span><br><span class="line"></span><br><span class="line">jQuery.contents(),返回下面的所有内容，包括节点和文本。这个方法和children()的区别就在于，包括空白文本，也会被作为一个jQuery对象返回，children()则只会返回节点</span><br><span class="line"></span><br><span class="line">jQuery.prev()，返回上一个兄弟节点，不是所有的兄弟节点</span><br><span class="line"></span><br><span class="line">jQuery.prevAll()，返回所有之前的兄弟节点</span><br><span class="line"></span><br><span class="line">jQuery.next(),返回下一个兄弟节点，不是所有的兄弟节点</span><br><span class="line"></span><br><span class="line">jQuery.nextAll()，返回所有之后的兄弟节点</span><br><span class="line"></span><br><span class="line">jQuery.siblings(),返回兄弟姐妹节点，不分前后</span><br><span class="line"></span><br><span class="line">jQuery.find(expr),跟jQuery.filter(expr)完全不一样。jQuery.filter()是从初始的jQuery对象集合中筛选出一部分，而jQuery.find()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
            <tag> jq </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
